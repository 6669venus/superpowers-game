module Sup {

  export function log(message, ...optionalParams) { console.log.apply(console, [ message ].concat(optionalParams)); }

  export function exit() {
    if (player.gameInstance.input.exited) return;
    player.gameInstance.input.emit("exit");
    player.gameInstance.input.exited = true;
    player.gameInstance.destroyAllActors();

    // Close window only if running release mode in NW.js
    if (!player.gameInstance.debug && window.nwDispatcher != null)
      window.nwDispatcher.requireNwGui().Window.get().close();
  }

  export class Asset {
    name: string;
    path: string;
    type: string;
    children: Array<string>;
    __inner: any;

    constructor(inner) {
      this.__inner = inner;
      this.__inner.__outer = this;
    }
  }

  export class Folder extends Asset {}

  export function get(path: string, arg1, arg2?) {
    let type = arg1;
    let options = (arg2 !== undefined) ? arg2 : { ignoreMissing: false };

    if (arg1 != null && Object.getPrototypeOf(arg1) == Object.prototype) {
      type = null;
      options = arg1;
    }

    let entry = player.entriesByPath[path];
    let outerAsset: any = null;

    if (entry) { outerAsset = player.getOuterAsset(entry.id); }
    else if(!options.ignoreMissing) throw new Error(`Invalid asset path: ${path}`);

    if (type != null && outerAsset != null) {
      let typeName = type.name.charAt(0).toLowerCase() + type.name.slice(1);
      if (typeName != outerAsset.type) throw new Error(`Invalid asset type: got ${outerAsset.type} but asked for ${typeName}`);
    }

    return outerAsset;
  }

  export function getActor(name) {
    let foundActor = null;
    player.gameInstance.tree.walkTopDown((actor) => {
      if (actor.name === name && !actor.pendingForDestruction) {
        foundActor = actor.__outer;
        return false;
      }
      return true;
    });
    return foundActor;
  }

  export function destroyAllActors() {
    player.gameInstance.destroyAllActors();
    player.gameInstance.tree.walkTopDown((actor) => { actor.__outer.__inner = null; actor.__outer = null; return true; });
  }

  export class ActorComponent {
    actor: Actor;
    __inner: any;

    constructor(actor) {
      this.actor = actor;
    }

    destroy() { player.gameInstance.destroyComponent(this.__inner); }
    isDestroyed() {
      return this.__inner == null ||
        this.__inner.actor.pendingForDestruction ||
        this.__inner.actor.gameInstance.componentsToBeDestroyed.indexOf(this.__inner) !== -1;
    }
  }

  export class Behavior extends ActorComponent {
    awake: Function;
    start: Function;
    update: Function;
    onDestroy: Function;

    constructor(actor) {
      if (actor.__outer == null) { throw new Error("Use actor.addBehavior to create a behavior"); }

      super(actor.__outer);

      let funcs = {};
      funcs["awake"]  = (this.awake)  ? this.awake.bind(this) : null;
      funcs["start"]  = (this.start)  ? this.start.bind(this) : null;
      funcs["update"] = (this.update) ? this.update.bind(this) : null;
      funcs["onDestroy"] = (this.onDestroy) ? this.onDestroy.bind(this) : null;
      this.__inner = new SupEngine.componentClasses.Behavior(actor, funcs);

      this.__inner.__outer = this;
      this.actor.__behaviors[this.constructor["name"]] = this;
    }
  }

  export function registerBehavior(behaviorClass) {
    player.behaviorClasses[behaviorClass.name] = behaviorClass;
    return behaviorClass;
  }
}

window.Sup = Sup;
