module Sup {

  let degToRad = window.Math.PI / 180;
  let radToDeg = 180 / window.Math.PI;

  let tmpVector3 = new SupEngine.THREE.Vector3();

  export module Math {

    export function clamp(v: number, min: number, max: number) { return window.Math.max(min, window.Math.min(max, v)); }

    export function lerp(a: number, b: number, v: number) { return a + (b - a) * v; }

    export function lerpAngle(a: number, b: number, v: number) {
      a = wrapAngle(a);
      b = wrapAngle(b);
      return a + wrapAngle(b - a) * v;
    }

    export function wrapAngle(a: number) {
      a %= (window.Math.PI * 2);
      if (a < -window.Math.PI) a += window.Math.PI * 2;
      else if (a > window.Math.PI) a -= window.Math.PI * 2;
      return a;
    }

    export module Random {
      export function integer(min: number, max: number) { return window.Math.floor(window.Math.random() * (max + 1 - min)) + min; }
      export function sample<T>(collection: T[]) { return collection[integer(0, collection.length - 1)]; }
    }

    export function toRadians(degrees: number) { return degrees * degToRad; }
    export function toDegrees(radians: number) { return radians * radToDeg; }

    export class Vector3 {
      static forward() { return new Vector3( 0,  0,  1); }
      static back()    { return new Vector3( 0,  0, -1); }
      static right()   { return new Vector3( 1,  0,  0); }
      static left()    { return new Vector3(-1,  0,  0); }
      static up()      { return new Vector3( 0,  1,  0); }
      static down()    { return new Vector3( 0, -1,  0); }

      x: number;
      y: number;
      z: number;

      constructor(x?: number, y?: number, z?: number) {
        if (x == null) x = 0;
        this.set(x, y, z);
      }

      toString() { return `{ x: ${this.x}, y: ${this.y}, z: ${this.z} }`; }

      set(x: number, y?: number, z?: number) {
        this.x = x;
        this.y = (y != null) ? y : x;
        this.z = (z != null) ? z : x;
        return this;
      }
      copy(v: Vector3) { this.x = v.x; this.y = v.y; this.z = v.z; return this; }
      clone() { return new Vector3(this.x, this.y, this.z); }

      add(x: number|Vector3, y?: number, z?: number) {
        if (y == null && z == null) {
          let v = <Vector3>x;
          this.x += v.x; this.y += v.y; this.z += v.z;
        } else {
          this.x += <number>x; this.y += y; this.z += z;
        }
        return this;
      }
      subtract(x: number|Vector3, y?: number, z?: number) {
        if (y == null && z == null) {
          let v = <Vector3>x;
          this.x -= v.x; this.y -= v.y; this.z -= v.z;
        } else {
          this.x -= <number>x; this.y -= y; this.z -= z;
        }
        return this;
      }
      multiplyScalar(m: number) { this.x *= m; this.y *= m; this.z *= m; return this; }

      cross(v: Vector3) {
        let x = this.x;
        let y = this.y;
        let z = this.z;

        this.x = y * v.z - z * v.y;
        this.y = z * v.x - x * v.z;
        this.z = x * v.y - y * v.x;
        return this;
      }

      dot(v: Vector3) { return this.x * v.x + this.y * v.y + this.z * v.z; }

      normalize() {
        let length = this.length();
        this.x /= length; this.y /= length; this.z /= length;
        return this;
      }
      negate() {
        this.x *= -1; this.y *= -1; this.z *= -1;
        return this;
      }

      lerp(v: Vector3, t: number) {
        this.x = this.x * (1 - t) + v.x * t;
        this.y = this.y * (1 - t) + v.y * t;
        this.z = this.z * (1 - t) + v.z * t;
        return this;
      }

      rotate(q: Quaternion) {
        let qx = q.x;
        let qy = q.y;
        let qz = q.z;
        let qw = q.w;

        let ix =  qw * this.x + qy * this.z - qz * this.y;
        let iy =  qw * this.y + qz * this.x - qx * this.z;
        let iz =  qw * this.z + qx * this.y - qy * this.x;
        let iw = - qx * this.x - qy * this.y - qz * this.z;

        this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
        this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
        this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;
        return this;
      }

      length() { return window.Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z); }
      distanceTo(v: Vector3) { return v.clone().subtract(this).length(); }
      angleTo(v: Vector3) {
        let theta = this.dot(v) / (this.length() * v.length());
		    return window.Math.acos(Math.clamp(theta, - 1, 1));
      }

      unproject(camera: Sup.Camera) {
        tmpVector3.set(this.x, this.y, this.z);
        tmpVector3.unproject(camera.__inner.threeCamera);
        this.set(tmpVector3.x, tmpVector3.y, tmpVector3.z);
        return this;
      }
    }

    export class Quaternion {
      x: number;
      y: number;
      z: number;
      w: number;

      constructor(x: number, y: number, z: number, w: number) {
        this.x = (x) ? x : 0;
        this.y = (y) ? y : 0;
        this.z = (z) ? z : 0;
        this.w = (w) ? w : 1;
      }

      toString() { return `{ x: ${this.x}, y: ${this.y}, z: ${this.z}, w: ${this.w} }`; }

      set(x: number, y: number, z: number, w: number) { this.x = x; this.y = y; this.z = z; this.w = w; return this; }
      copy(q: Quaternion) { this.x = q.x; this.y = q.y; this.z = q.z; this.w = q.w; return this; }
      clone() { return new Quaternion(this.x, this.y, this.z, this.w); }

      setFromAxisAngle(axis: Vector3, angle: number) {
        let s = window.Math.sin(angle / 2);

    		this.x = axis.x * s;
    		this.y = axis.y * s;
    		this.z = axis.z * s;
    		this.w = window.Math.cos(angle / 2);
        return this;
      }

      setFromYawPitchRoll(yaw: number, pitch: number, roll: number) {
        let c1 = window.Math.cos(pitch / 2);
        let c2 = window.Math.cos(yaw / 2);
        let c3 = window.Math.cos(roll / 2);
        let s1 = window.Math.sin(pitch / 2);
        let s2 = window.Math.sin(yaw / 2);
        let s3 = window.Math.sin(roll / 2);

        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;
        return this;
      }

      multiplyQuaternions(a: Quaternion, b: Quaternion) {
        let qax = a.x;
        let qay = a.y;
        let qaz = a.z;
        let qaw = a.w;

        let qbx = b.x;
        let qby = b.y;
        let qbz = b.z;
        let qbw = b.w;

        this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

        return this;
      }

      multiply(q: Quaternion) { return this.multiplyQuaternions(this, q); }

      slerp(q: Quaternion, t: number) {
        // Adapted from Three.js
        if (t === 0) return this;
        if (t === 1) return this.copy(q);

        let x = this.x;
        let y = this.y;
        let z = this.z;
        let w = this.w;

        let cosHalfTheta = w * q.w + x * q.x + y * q.y + z * q.z;

        if (cosHalfTheta < 0) {
          this.w = -q.w;
          this.x = -q.x;
          this.y = -q.y;
          this.z = -q.z;
          cosHalfTheta = -cosHalfTheta;
        } else {
          this.copy(q);
        }

        if (cosHalfTheta >= 1.0) {
          this.w = w;
          this.x = x;
          this.y = y;
          this.z = z;
          return this;
        }

        let halfTheta = window.Math.acos(cosHalfTheta);
        let sinHalfTheta = window.Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);

        if (window.Math.abs(sinHalfTheta) < 0.001) {
          this.w = 0.5 * (w + this.w);
          this.x = 0.5 * (x + this.x);
          this.y = 0.5 * (y + this.y);
          this.z = 0.5 * (z + this.z);
          return this;
        }

        let ratioA = window.Math.sin((1 - t) * halfTheta) / sinHalfTheta,
        ratioB = window.Math.sin(t * halfTheta) / sinHalfTheta;

        this.w = (w * ratioA + this.w * ratioB);
        this.x = (x * ratioA + this.x * ratioB);
        this.y = (y * ratioA + this.y * ratioB);
        this.z = (z * ratioA + this.z * ratioB);
        return this;
      }
    }

    export class Plane {
      _normal = new Vector3();
      _distance: number;

      constructor(normal?: Vector3, distance?: number) {
        this.setFromDistance(normal, distance);
      }
      setFromDistance(normal: Vector3, distance: number) {
        if (normal != null) this._normal.copy(normal).normalize();
        if (distance != null) this._distance = distance;
        return this;
      }
      setFromPoint(normal: Vector3, point: Vector3) {
        this._normal.copy(normal).normalize();
        this._distance = point.dot(this._normal);
        return this;
      }
      getNormal() { return this._normal.clone(); }
      getDistance() { return this._distance; }
      distanceToPoint(point: Vector3) { return this._normal.dot(point) + this._distance; }
      projectPoint(point: Vector3) {
        return this._normal.clone()
          .multiplyScalar(this.distanceToPoint(point))
          .subtract(point)
          .negate();
      }
    }

    interface ActorRaycastHit {
      actor: Sup.Actor;
      distance: number;
      point: Vector3;
      normal: Vector3;
    }

    export class Ray {
      _raycaster = new SupEngine.THREE.Raycaster();

      constructor(origin?: Vector3, direction?: Vector3) {
        if (origin != null) this._raycaster.ray.origin.copy(origin);
        if (direction != null) this._raycaster.ray.direction.copy(direction).normalize();
      }

      setOrigin(x: number|Vector3, y?: number, z?: number) {
        if (y == null && z == null) this._raycaster.ray.origin.copy(x);
        else this._raycaster.ray.origin.set(x, y, z);
        return this;
      }
      getOrigin() { return new Vector3(this._raycaster.ray.origin.x, this._raycaster.ray.origin.y, this._raycaster.ray.origin.z); }

      setDirection(x: number|Vector3, y?: number, z?: number) {
        if (y == null && z == null) this._raycaster.ray.direction.copy(x).normalize();
        else this._raycaster.ray.direction.set(x, y, z).normalize();
        return this;
      }
      getDirection() { return new Vector3(this._raycaster.ray.direction.x, this._raycaster.ray.direction.y, this._raycaster.ray.direction.z); }

      setFromCamera(camera: Sup.Camera, screenPosition: { x: number; y: number; }) {
        let threeCamera = camera.__inner.threeCamera;
        let viewport = camera.__inner.viewport;
        let position = { x: screenPosition.x, y: screenPosition.y };
        position.x -= viewport.width - 1 + viewport.x / viewport.width;
        position.x /= viewport.width;
        position.y += viewport.height - 1 + viewport.y / viewport.height;
        position.y /= viewport.height;

        if (camera.getOrthographicMode()) {
          this._raycaster.ray.origin.set(position.x, position.y, - 1).unproject(threeCamera);
          this._raycaster.ray.direction.set(0, 0, - 1).transformDirection(threeCamera.matrixWorld);
        } else {
          this._raycaster.ray.origin.copy(threeCamera.position);
          this._raycaster.ray.direction.set(position.x, position.y, 0.5).unproject(threeCamera).sub(threeCamera.position).normalize();
        }
      }

      _raycast(actor: Sup.Actor, results: ActorRaycastHit[]) {
        let result: any;

        let walk = (object: any) => {
          let intersect = this._raycaster.intersectObject(object);
          if (intersect.length != 0) {
            result = intersect[0];
            return true;
          }
          for (let child of object.children) {
            if (child.userData.isActor == true) continue;
            if (walk(child)) return true;
          }
          return false;
        }
        walk(actor.__inner.threeObject);

        if (result != null) {
          results.push({
            actor,
            distance: result.distance,
            point: new Vector3(result.point.x, result.point.y, result.point.z),
            normal: new Vector3(result.face.normal.x, result.face.normal.y, result.face.normal.z)
          });
        }
      }

      intersectActor(actor: Sup.Actor, recursive=false) {
        let results = <ActorRaycastHit[]>[];

        let walk = (childActor: Sup.Actor) => {
          this._raycast(childActor, results);
          if (recursive)
            for (let child of childActor.__inner.children) walk(child.__outer);
        }
        walk(actor);

        results.sort((a, b) => { return a.distance - b.distance; });
        return results;
      }

      intersectActors(actors: Sup.Actor[]) {
        let results = <ActorRaycastHit[]>[];

        for (let actor of actors) this._raycast(actor, results);

        results.sort((a, b) => { return a.distance - b.distance; });
        return results;
      }

      intersectPlane(plane: Plane) {
        let distance: number;
        let point = new Vector3(this._raycaster.ray.origin.x, this._raycaster.ray.origin.y, this._raycaster.ray.origin.z);

        let denominator = plane.getNormal().dot(this._raycaster.ray.direction);
        if (denominator === 0) { // normal and direction are perpendicular
          if (plane.distanceToPoint(this._raycaster.ray.origin) === 0) return { distance: 0, point };
          else return null;
        }

        distance = -(this._raycaster.ray.origin.dot(plane.getNormal()) + plane.getDistance()) / denominator;
        if (distance < 0) return null;

        point.add(this.getDirection().multiplyScalar(distance));
        return { distance, point };
      }
    }
  }
}
