declare module Sup {
  module Math {
    function clamp(v: number, min: number, max: number): number;

    function lerp(a: number, b: number, v: number): number;
    function lerpAngle(a: number, b: number, v: number): number;
    function wrapAngle(a);

    module Random {
      function integer(min: number, max: number): number;
      function sample<T>(collection: T[]): T;
    }

    function toRadians(degrees: number): number;
    function toDegrees(radians: number): number;

    class Vector3 {
      static forward(): Vector3;
      static back(): Vector3;
      static right(): Vector3;
      static left(): Vector3;
      static up(): Vector3;
      static down(): Vector3;
      static one(): Vector3;

      x: number;
      y: number;
      z: number;

      constructor();
      constructor(x: number, y: number, z: number);
      constructor(xyz: number);
      set(x: number, y: number, z: number): Vector3;
      set(xyz: number): Vector3;
      copy(v: {x: number; y: number; z: number;}): Vector3;
      clone(): Vector3;

      add(v: Vector3): Vector3;
      add(x: number, y: number, z: number): Vector3;
      subtract(v: Vector3): Vector3;
      subtract(x: number, y: number, z: number): Vector3;
      multiplyScalar(m: number): Vector3;
      cross(v: Vector3): Vector3;
      dot(v: Vector3): number;
      normalize(): Vector3;
      negate(): Vector3;
      lerp(v: Vector3, t: number): Vector3;
      rotate(q : Quaternion): Vector3;
      length(): number;
      distanceTo(v: Vector3): number;
      angleTo(v: Vector3): number;
      unproject(camera: Camera): Vector3;
    }

    class Quaternion {
      x: number;
      y: number;
      z: number;
      w: number;

      constructor(x?: number, y?: number, z?: number, w?: number);

      set(x: number, y: number, z: number, w: number): Quaternion;
      setFromAxisAngle(axis: Vector3, angle: number): Quaternion;
      setFromYawPitchRoll(yaw: number, pitch: number, roll: number): Quaternion;
      copy(q: Quaternion): Quaternion;
      clone(): Quaternion;

      multiplyQuaternions(a: Quaternion, b: Quaternion): Quaternion;
      multiply(q: Quaternion): Quaternion;
      slerp(q: Quaternion, t: number): Quaternion;
    }

    class Plane {
      constructor();
      constructor(normal: Vector3, distance: number);
      setFromDistance(normal: Vector3, distance: number): Plane;
      setFromPoint(normal: Vector3, point: Vector3): Plane;
      getNormal(): Vector3;
      getDistance(): number;
      distanceToPoint(point: Vector3): number;
      projectPoint(point: Vector3): Vector3;
    }

    interface RaycastResult {
      actor: Sup.Actor;
      distance: number;
      point: Vector3;
      normal: Vector3;
    }

    class Ray {
      constructor(origin?: Vector3, direction?: Vector3);
      setOrigin(origin: Vector3): Ray;
      getOrigin(): Vector3;
      setDirection(direction: Vector3): Ray;
      getDirection(): Vector3;
      setFromCamera(camera: Sup.Camera, position: { x: number; y: number; }): Ray;
      intersectActor(actor: Sup.Actor, recursive?: boolean): RaycastResult[];
      intersectActors(actors: Sup.Actor[]): RaycastResult[];
      intersectPlane(plane: Plane): { distance: number; point: number; };
    }
  }
}
