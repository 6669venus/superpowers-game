module Sup {
  export module ArcadePhysics2D {
    export enum BodyType { Box, TileMap };

    export class Body extends ActorComponent {
      constructor(actor, type, options) {
        super(actor);

        this.__inner = new SupEngine.componentClasses.ArcadeBody2D(actor.__inner);
        if (type === Sup.ArcadePhysics2D.BodyType.Box) this.__inner.setupBox(options);
        else if (type === Sup.ArcadePhysics2D.BodyType.TileMap) {
          options.tileSetAsset = player.getOuterAsset(options.tileMapAsset.__inner.data.tileSetId);
          this.__inner.setupTileMap(options);
        }
        this.__inner.__outer = this;
        this.actor.arcadeBody2D = this;
      }
      destroy() {
        this.actor.arcadeBody2D = null;
        super.destroy();
      }

      setMovable(movable) {
        this.__inner.movable = movable;
        return this;
      }
      getMovable() { return this.__inner.movable; }

      setSize(width, height) {
        this.__inner.width = width;
        this.__inner.height = height;
        return this;
      }
      getSize() { return { width: this.__inner.width, height: this.__inner.height}; }

      setOffset(offset) {
        this.__inner.offsetX = offset.x;
        this.__inner.offsetY = (SupEngine.ArcadePhysics2D.plane === "XY") ? offset.y : offset.z;
        this.__inner.refreshActorPosition();
        return this;
      }
      getOffset() {
        let offset: any = { x: this.__inner.offsetX };
        if (SupEngine.ArcadePhysics2D.plane === "XY") offset.y = this.__inner.offsetY;
        else offset.z = this.__inner.offsetY;
        return offset;
      }

      warpPosition(position) { this.__inner.warpPosition(position); }

      setVelocity(velocity) {
        this.__inner.velocity.x = velocity.x;
        this.__inner.velocity.y = velocity.y;
        this.__inner.velocity.z = velocity.z;
        return this;
      }
      getVelocity() { return new Sup.Math.Vector3(this.__inner.velocity.x, this.__inner.velocity.y, this.__inner.velocity.z) }

      setVelocityMin(velocityMin) {
        this.__inner.velocityMin.x = velocityMin.x;
        this.__inner.velocityMin.y = velocityMin.y;
        return this;
      }
      getVelocityMin() { return new Sup.Math.Vector3(this.__inner.velocityMin.x, this.__inner.velocityMin.y, 0) }

      setVelocityMax(velocityMax) {
        this.__inner.velocityMax.x = velocityMax.x;
        this.__inner.velocityMax.y = velocityMax.y;
        return this;
      }
      getVelocityMax() { return new Sup.Math.Vector3(this.__inner.velocityMax.x, this.__inner.velocityMax.y, 0) }

      setVelocityMultiplier(velocityMultiplier) {
        this.__inner.velocityMultiplier.x = velocityMultiplier.x;
        this.__inner.velocityMultiplier.y = velocityMultiplier.y;
        return this;
      }
      getVelocityMultiplier() { return new Sup.Math.Vector3(this.__inner.velocityMultiplier.x, this.__inner.velocityMultiplier.y, 1) }

      setAngularVelocity(angularVelocity) {
        this.__inner.angularVelocity = angularVelocity;
        return this;
      }
      getAngularVelocity() { return this.__inner.angularVelocity }

      setAngularVelocityMultiplier(angularVelocityMultiplier) {
        this.__inner.angularVelocityMultiplier = angularVelocityMultiplier
        return this;
      }
      getAngularVelocityMultiplier() { return this.__inner.angularVelocityMultiplier; }

      getTouches() {
        return {
          left: this.__inner.touches.left, right : this.__inner.touches.right,
          top : this.__inner.touches.top , bottom: this.__inner.touches.bottom,
          back: this.__inner.touches.top , front : this.__inner.touches.bottom,
        };
      }
    }
  }
}
